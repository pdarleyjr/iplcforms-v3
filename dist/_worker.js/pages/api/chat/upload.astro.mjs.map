{"version":3,"file":"upload.astro.mjs","sources":["../../../../../src/pages/api/chat/upload.ts"],"sourcesContent":["import type { APIRoute } from 'astro';\r\nimport { nanoid } from 'nanoid';\r\nimport type { AIEnv } from '../../../lib/ai';\r\n\r\nexport const POST: APIRoute = async ({ request, locals }) => {\r\n  const env = (locals as any).runtime.env as unknown as AIEnv;\r\n  \r\n  try {\r\n    const formData = await request.formData();\r\n    const files = formData.getAll('files') as File[];\r\n    const conversationId = formData.get('conversationId') as string || nanoid();\r\n    \r\n    if (!files || files.length === 0) {\r\n      return new Response(JSON.stringify({ error: 'No files provided' }), {\r\n        status: 400,\r\n        headers: { 'Content-Type': 'application/json' }\r\n      });\r\n    }\r\n\r\n    // Use IPLC_AI service binding\r\n    const iplcAI = (env as any).IPLC_AI;\r\n    if (!iplcAI || typeof iplcAI.fetch !== 'function') {\r\n      return new Response(JSON.stringify({\r\n        error: 'AI service not available',\r\n        details: 'IPLC_AI service binding is not configured'\r\n      }), {\r\n        status: 503,\r\n        headers: { 'Content-Type': 'application/json' }\r\n      });\r\n    }\r\n\r\n    const uploadedDocuments = [];\r\n\r\n    for (const file of files) {\r\n      const documentId = nanoid();\r\n      const buffer = await file.arrayBuffer();\r\n      const text = await extractTextFromFile(file, buffer);\r\n      \r\n      // Split text into chunks for better retrieval\r\n      const chunks = splitTextIntoChunks(text, 600);\r\n      \r\n      // Convert file to base64 for transmission\r\n      const base64Content = btoa(String.fromCharCode.apply(null, Array.from(new Uint8Array(buffer))));\r\n      \r\n      // Call the iplc-ai worker's /documents/upload endpoint\r\n      const uploadResponse = await iplcAI.fetch('https://iplc-ai.worker/documents/upload', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          documentId,\r\n          documentName: file.name,\r\n          documentType: file.type,\r\n          chunks: chunks,\r\n          conversationId\r\n        })\r\n      });\r\n      \r\n      if (!uploadResponse.ok) {\r\n        const error = await uploadResponse.text();\r\n        console.error(`Failed to upload ${file.name}:`, error);\r\n        continue;\r\n      }\r\n      \r\n      const result = await uploadResponse.json();\r\n      \r\n      uploadedDocuments.push({\r\n        id: documentId,\r\n        name: file.name,\r\n        size: file.size,\r\n        type: file.type,\r\n        uploadedAt: new Date().toISOString(),\r\n        conversationId,\r\n        chunks: chunks.length,\r\n        vectorIds: result.vectorIds\r\n      });\r\n    }\r\n\r\n    // Create or update conversation\r\n    const conversation = await env.CHAT_HISTORY.get(`conv:${conversationId}`);\r\n    if (!conversation) {\r\n      await env.CHAT_HISTORY.put(\r\n        `conv:${conversationId}`,\r\n        JSON.stringify({\r\n          id: conversationId,\r\n          title: `Chat about ${files[0].name}`,\r\n          createdAt: new Date().toISOString(),\r\n          lastMessage: '',\r\n          timestamp: new Date().toISOString()\r\n        })\r\n      );\r\n    }\r\n\r\n    return new Response(JSON.stringify({\r\n      success: true,\r\n      conversationId,\r\n      documents: uploadedDocuments\r\n    }), {\r\n      headers: { 'Content-Type': 'application/json' }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Upload error:', error);\r\n    return new Response(JSON.stringify({ \r\n      error: 'Failed to upload files',\r\n      details: error instanceof Error ? error.message : 'Unknown error'\r\n    }), {\r\n      status: 500,\r\n      headers: { 'Content-Type': 'application/json' }\r\n    });\r\n  }\r\n};\r\n\r\nasync function extractTextFromFile(file: File, buffer: ArrayBuffer): Promise<string> {\r\n  const type = file.type;\r\n  const decoder = new TextDecoder();\r\n  \r\n  // Handle text-based files\r\n  if (type.includes('text') || \r\n      type.includes('json') || \r\n      type.includes('csv') ||\r\n      file.name.endsWith('.md') ||\r\n      file.name.endsWith('.txt')) {\r\n    return decoder.decode(buffer);\r\n  }\r\n  \r\n  // For PDF and other binary formats, we'd need a proper parser\r\n  // For now, we'll just return a placeholder\r\n  // In production, you'd use libraries like pdf-parse\r\n  if (type.includes('pdf')) {\r\n    return `[PDF content from ${file.name} - parsing not implemented]`;\r\n  }\r\n  \r\n  if (type.includes('doc')) {\r\n    return `[Document content from ${file.name} - parsing not implemented]`;\r\n  }\r\n  \r\n  return `[Binary file ${file.name} - content extraction not supported]`;\r\n}\r\n\r\nfunction splitTextIntoChunks(text: string, chunkSize: number): string[] {\r\n  const chunks: string[] = [];\r\n  const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];\r\n  \r\n  let currentChunk = '';\r\n  \r\n  for (const sentence of sentences) {\r\n    if (currentChunk.length + sentence.length > chunkSize && currentChunk.length > 0) {\r\n      chunks.push(currentChunk.trim());\r\n      currentChunk = sentence;\r\n    } else {\r\n      currentChunk += ' ' + sentence;\r\n    }\r\n  }\r\n  \r\n  if (currentChunk.trim()) {\r\n    chunks.push(currentChunk.trim());\r\n  }\r\n  \r\n  return chunks;\r\n}"],"names":[],"mappings":"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"}