{"version":3,"file":"rateLimit_B8vzP1Fn.mjs","sources":["../../../src/lib/ai/rateLimit.ts"],"sourcesContent":["/**\n * Rate limiting module for the single-worker RAG implementation\n * Reference: \"Single-Worker RAG Implementation.txt\" - Rate Limiting\n * \n * Implements token bucket algorithm for request rate limiting\n */\n\nimport type { AIEnv, RateLimitInfo } from './types';\n\n// Rate limit configuration as per spec\nconst RATE_LIMIT_CONFIG = {\n  tokensPerMinute: 60,\n  burstSize: 10,\n  refillRate: 1, // 1 token per second\n};\n\n/**\n * Check rate limit for a given client/session\n * Reference: \"Single-Worker RAG Implementation.txt\" - Token Bucket Implementation\n * \n * @param clientId - Unique identifier for the client (IP or session ID)\n * @param env - Worker environment\n * @returns Rate limit info with allowed status\n */\nexport async function checkRateLimit(\n  clientId: string,\n  env: AIEnv\n): Promise<RateLimitInfo> {\n  const key = `ratelimit:${clientId}`;\n  const now = Date.now();\n  \n  try {\n    // Get current bucket state\n    const bucketData = await env.CHAT_HISTORY.get(key, 'json') as {\n      tokens: number;\n      lastRefill: number;\n    } | null;\n    \n    let tokens = RATE_LIMIT_CONFIG.burstSize;\n    let lastRefill = now;\n    \n    if (bucketData) {\n      // Calculate tokens to add based on time elapsed\n      const timePassed = (now - bucketData.lastRefill) / 1000; // seconds\n      const tokensToAdd = Math.floor(timePassed * RATE_LIMIT_CONFIG.refillRate);\n      \n      tokens = Math.min(\n        bucketData.tokens + tokensToAdd,\n        RATE_LIMIT_CONFIG.burstSize\n      );\n      lastRefill = bucketData.lastRefill + (tokensToAdd * 1000);\n    }\n    \n    // Check if request is allowed\n    if (tokens >= 1) {\n      // Consume a token\n      tokens -= 1;\n      \n      // Update bucket state\n      await env.CHAT_HISTORY.put(\n        key,\n        JSON.stringify({ tokens, lastRefill }),\n        {\n          expirationTtl: 300, // 5 minutes TTL\n        }\n      );\n      \n      return {\n        allowed: true,\n        remaining: tokens,\n        resetAt: lastRefill + ((RATE_LIMIT_CONFIG.burstSize - tokens) * 1000),\n      };\n    } else {\n      // Request denied\n      const resetAt = lastRefill + (1000 / RATE_LIMIT_CONFIG.refillRate);\n      \n      return {\n        allowed: false,\n        remaining: 0,\n        resetAt,\n      };\n    }\n  } catch (error) {\n    console.error('Rate limit check error:', error);\n    // Allow request on error to avoid blocking users\n    return {\n      allowed: true,\n      remaining: RATE_LIMIT_CONFIG.burstSize - 1,\n      resetAt: now + 60000,\n    };\n  }\n}\n\n/**\n * Apply rate limit headers to response\n * Reference: \"Single-Worker RAG Implementation.txt\" - Rate Limiting\n * \n * @param response - Response object\n * @param rateLimitInfo - Rate limit information\n * @returns Response with rate limit headers\n */\nexport function applyRateLimitHeaders(\n  response: Response,\n  rateLimitInfo: RateLimitInfo\n): Response {\n  const headers = new Headers(response.headers);\n  \n  headers.set('X-RateLimit-Limit', RATE_LIMIT_CONFIG.tokensPerMinute.toString());\n  headers.set('X-RateLimit-Remaining', rateLimitInfo.remaining.toString());\n  headers.set('X-RateLimit-Reset', Math.floor(rateLimitInfo.resetAt / 1000).toString());\n  \n  if (!rateLimitInfo.allowed) {\n    headers.set('Retry-After', Math.ceil((rateLimitInfo.resetAt - Date.now()) / 1000).toString());\n  }\n  \n  return new Response(response.body, {\n    status: response.status,\n    statusText: response.statusText,\n    headers,\n  });\n}\n\n/**\n * Create rate limit exceeded response\n * Reference: \"Single-Worker RAG Implementation.txt\" - Error Handling\n * \n * @param rateLimitInfo - Rate limit information\n * @returns 429 response with error details\n */\nexport function createRateLimitResponse(rateLimitInfo: RateLimitInfo): Response {\n  const resetInSeconds = Math.ceil((rateLimitInfo.resetAt - Date.now()) / 1000);\n  \n  const response = new Response(\n    JSON.stringify({\n      error: 'Rate limit exceeded',\n      message: `Too many requests. Please retry after ${resetInSeconds} seconds.`,\n      retryAfter: resetInSeconds,\n    }),\n    {\n      status: 429,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    }\n  );\n  \n  return applyRateLimitHeaders(response, rateLimitInfo);\n}\n\n/**\n * Get client identifier from request\n * Reference: \"Single-Worker RAG Implementation.txt\" - Rate Limiting\n * \n * @param request - Incoming request\n * @returns Client identifier (IP or session ID)\n */\nexport function getClientId(request: Request): string {\n  // Try to get session ID from headers or query params\n  const url = new URL(request.url);\n  const sessionId = request.headers.get('X-Session-ID') || \n                   url.searchParams.get('sessionId');\n  \n  if (sessionId) {\n    return `session:${sessionId}`;\n  }\n  \n  // Fall back to CF-Connecting-IP\n  const ip = request.headers.get('CF-Connecting-IP') || 'unknown';\n  return `ip:${ip}`;\n}\n\n/**\n * Rate limit middleware function\n * Reference: \"Single-Worker RAG Implementation.txt\" - API Integration\n * \n * @param request - Incoming request\n * @param env - Worker environment\n * @param handler - Request handler function\n * @returns Response with rate limiting applied\n */\nexport async function withRateLimit(\n  request: Request,\n  env: AIEnv,\n  handler: (request: Request) => Promise<Response>\n): Promise<Response> {\n  const clientId = getClientId(request);\n  const rateLimitInfo = await checkRateLimit(clientId, env);\n  \n  if (!rateLimitInfo.allowed) {\n    return createRateLimitResponse(rateLimitInfo);\n  }\n  \n  // Execute handler and apply rate limit headers\n  const response = await handler(request);\n  return applyRateLimitHeaders(response, rateLimitInfo);\n}\n\n/**\n * Get rate limit status without consuming a token\n * Reference: \"Single-Worker RAG Implementation.txt\" - Rate Limiting\n * \n * @param clientId - Client identifier\n * @param env - Worker environment\n * @returns Current rate limit status\n */\nexport async function getRateLimitStatus(\n  clientId: string,\n  env: AIEnv\n): Promise<RateLimitInfo> {\n  const key = `ratelimit:${clientId}`;\n  const now = Date.now();\n  \n  try {\n    const bucketData = await env.CHAT_HISTORY.get(key, 'json') as {\n      tokens: number;\n      lastRefill: number;\n    } | null;\n    \n    if (!bucketData) {\n      return {\n        allowed: true,\n        remaining: RATE_LIMIT_CONFIG.burstSize,\n        resetAt: now + 60000,\n      };\n    }\n    \n    // Calculate current tokens without consuming\n    const timePassed = (now - bucketData.lastRefill) / 1000;\n    const tokensToAdd = Math.floor(timePassed * RATE_LIMIT_CONFIG.refillRate);\n    const currentTokens = Math.min(\n      bucketData.tokens + tokensToAdd,\n      RATE_LIMIT_CONFIG.burstSize\n    );\n    \n    return {\n      allowed: currentTokens >= 1,\n      remaining: currentTokens,\n      resetAt: bucketData.lastRefill + ((RATE_LIMIT_CONFIG.burstSize - currentTokens) * 1000),\n    };\n  } catch (error) {\n    console.error('Get rate limit status error:', error);\n    return {\n      allowed: true,\n      remaining: RATE_LIMIT_CONFIG.burstSize,\n      resetAt: now + 60000,\n    };\n  }\n}"],"names":[],"mappings":";AAUA,MAAM,iBAAA,GAAoB;AAAA,EACxB,eAAA,EAAiB,EAAA;AAAA,EACjB,SAAA,EAAW,EAAA;AAAA,EACX,UAAA,EAAY;AAAA;AACd,CAAA;AAUA,eAAsB,cAAA,CACpB,UACA,GAAA,EACwB;AACxB,EAAA,MAAM,GAAA,GAAM,aAAa,QAAQ,CAAA,CAAA;AACjC,EAAA,MAAM,GAAA,GAAM,KAAK,GAAA,EAAI;AAErB,EAAA,IAAI;AAEF,IAAA,MAAM,aAAa,MAAM,GAAA,CAAI,YAAA,CAAa,GAAA,CAAI,KAAK,MAAM,CAAA;AAKzD,IAAA,IAAI,SAAS,iBAAA,CAAkB,SAAA;AAC/B,IAAA,IAAI,UAAA,GAAa,GAAA;AAEjB,IAAA,IAAI,UAAA,EAAY;AAEd,MAAA,MAAM,UAAA,GAAA,CAAc,GAAA,GAAM,UAAA,CAAW,UAAA,IAAc,GAAA;AACnD,MAAA,MAAM,WAAA,GAAc,IAAA,CAAK,KAAA,CAAM,UAAA,GAAa,kBAAkB,UAAU,CAAA;AAExE,MAAA,MAAA,GAAS,IAAA,CAAK,GAAA;AAAA,QACZ,WAAW,MAAA,GAAS,WAAA;AAAA,QACpB,iBAAA,CAAkB;AAAA,OACpB;AACA,MAAA,UAAA,GAAa,UAAA,CAAW,aAAc,WAAA,GAAc,GAAA;AAAA,IACtD;AAGA,IAAA,IAAI,UAAU,CAAA,EAAG;AAEf,MAAA,MAAA,IAAU,CAAA;AAGV,MAAA,MAAM,IAAI,YAAA,CAAa,GAAA;AAAA,QACrB,GAAA;AAAA,QACA,IAAA,CAAK,SAAA,CAAU,EAAE,MAAA,EAAQ,YAAY,CAAA;AAAA,QACrC;AAAA,UACE,aAAA,EAAe;AAAA;AAAA;AACjB,OACF;AAEA,MAAA,OAAO;AAAA,QACL,OAAA,EAAS,IAAA;AAAA,QACT,SAAA,EAAW,MAAA;AAAA,QACX,OAAA,EAAS,UAAA,GAAA,CAAe,iBAAA,CAAkB,SAAA,GAAY,MAAA,IAAU;AAAA,OAClE;AAAA,IACF,CAAA,MAAO;AAEL,MAAA,MAAM,OAAA,GAAU,UAAA,GAAc,GAAA,GAAO,iBAAA,CAAkB,UAAA;AAEvD,MAAA,OAAO;AAAA,QACL,OAAA,EAAS,KAAA;AAAA,QACT,SAAA,EAAW,CAAA;AAAA,QACX;AAAA,OACF;AAAA,IACF;AAAA,EACF,SAAS,KAAA,EAAO;AACd,IAAA,OAAA,CAAQ,KAAA,CAAM,2BAA2B,KAAK,CAAA;AAE9C,IAAA,OAAO;AAAA,MACL,OAAA,EAAS,IAAA;AAAA,MACT,SAAA,EAAW,kBAAkB,SAAA,GAAY,CAAA;AAAA,MACzC,SAAS,GAAA,GAAM;AAAA,KACjB;AAAA,EACF;AACF;;;;"}