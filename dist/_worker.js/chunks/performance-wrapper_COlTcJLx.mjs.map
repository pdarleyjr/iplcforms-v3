{"version":3,"file":"performance-wrapper_COlTcJLx.mjs","sources":["../../../src/lib/utils/performance-wrapper.ts"],"sourcesContent":["import type { APIRoute } from 'astro';\r\nimport { WorkersPerformanceManager } from './workers-performance';\r\n\r\n/**\r\n * Higher-order function to wrap API routes with performance monitoring\r\n * @param route The API route handler to wrap\r\n * @param routeName Optional name for the route (defaults to route function name)\r\n * @returns Wrapped API route with performance monitoring\r\n */\r\nexport function withPerformanceMonitoring(\r\n  route: APIRoute,\r\n  routeName?: string\r\n): APIRoute {\r\n  return async (context) => {\r\n    const performanceManager = WorkersPerformanceManager.getInstance();\r\n    const startTime = Date.now();\r\n    const method = context.request.method;\r\n    const url = new URL(context.request.url);\r\n    const pathname = url.pathname;\r\n    \r\n    // Generate a unique key for this route\r\n    const metricsKey = routeName || `${method} ${pathname}`;\r\n    \r\n    try {\r\n      // Call the original route handler\r\n      const response = await route(context);\r\n      \r\n      // Record performance metrics\r\n      const duration = Date.now() - startTime;\r\n      performanceManager.recordRequest(metricsKey, {\r\n        requestId: crypto.randomUUID(),\r\n        startTime,\r\n        endTime: startTime + duration,\r\n        duration,\r\n        statusCode: response.status,\r\n        responseSize: parseInt(response.headers.get('content-length') || '0', 10),\r\n        cacheHits: response.headers.has('x-cache-hit') ? 1 : 0,\r\n        cacheMisses: response.headers.has('x-cache-hit') ? 0 : 1,\r\n        dbQueries: 0,\r\n        dbDuration: 0,\r\n        apiCalls: 0,\r\n        apiDuration: 0,\r\n        errors: 0\r\n      });\r\n      \r\n      return response;\r\n    } catch (error) {\r\n      // Record error metrics\r\n      const duration = Date.now() - startTime;\r\n      performanceManager.recordRequest(metricsKey, {\r\n        requestId: crypto.randomUUID(),\r\n        startTime,\r\n        endTime: startTime + duration,\r\n        duration,\r\n        statusCode: 500,\r\n        responseSize: 0,\r\n        cacheHits: 0,\r\n        cacheMisses: 1,\r\n        dbQueries: 0,\r\n        dbDuration: 0,\r\n        apiCalls: 0,\r\n        apiDuration: 0,\r\n        errors: 1\r\n      });\r\n      \r\n      // Re-throw the error to maintain original error handling\r\n      throw error;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Batch wrap multiple API routes with performance monitoring\r\n * @param routes Object containing route handlers\r\n * @param prefix Optional prefix for route names\r\n * @returns Object with wrapped route handlers\r\n */\r\nexport function withPerformanceMonitoringBatch<T extends Record<string, APIRoute>>(\r\n  routes: T,\r\n  prefix?: string\r\n): T {\r\n  const wrappedRoutes = {} as T;\r\n  \r\n  for (const [key, route] of Object.entries(routes)) {\r\n    const routeName = prefix ? `${prefix}:${key}` : key;\r\n    wrappedRoutes[key as keyof T] = withPerformanceMonitoring(route, routeName) as T[keyof T];\r\n  }\r\n  \r\n  return wrappedRoutes;\r\n}\r\n\r\n/**\r\n * Middleware to add performance headers to responses\r\n * @param response The response object\r\n * @param metrics Performance metrics for the request\r\n * @returns Response with performance headers\r\n */\r\nexport function addPerformanceHeaders(\r\n  response: Response,\r\n  metrics: {\r\n    duration: number;\r\n    cacheHit: boolean;\r\n    edgeLocation: string;\r\n  }\r\n): Response {\r\n  const headers = new Headers(response.headers);\r\n  \r\n  // Add Server-Timing header for performance insights\r\n  headers.set('Server-Timing', `total;dur=${metrics.duration}`);\r\n  \r\n  // Add custom performance headers\r\n  headers.set('X-Response-Time', `${metrics.duration}ms`);\r\n  if (metrics.cacheHit) {\r\n    headers.set('X-Cache-Hit', 'true');\r\n  }\r\n  headers.set('X-Edge-Location', metrics.edgeLocation);\r\n  \r\n  return new Response(response.body, {\r\n    status: response.status,\r\n    statusText: response.statusText,\r\n    headers\r\n  });\r\n}\r\n\r\n/**\r\n * Utility to measure async operation performance\r\n * @param operation The async operation to measure\r\n * @param operationName Name for logging/metrics\r\n * @returns Result of the operation\r\n */\r\nexport async function measureAsyncOperation<T>(\r\n  operation: () => Promise<T>,\r\n  operationName: string\r\n): Promise<T> {\r\n  const performanceManager = WorkersPerformanceManager.getInstance();\r\n  const startTime = Date.now();\r\n  \r\n  try {\r\n    const result = await operation();\r\n    const duration = Date.now() - startTime;\r\n    \r\n    // Record as a sub-operation\r\n    performanceManager.recordRequest(`async:${operationName}`, {\r\n      requestId: crypto.randomUUID(),\r\n      startTime,\r\n      endTime: startTime + duration,\r\n      duration,\r\n      statusCode: 200,\r\n      responseSize: 0,\r\n      cacheHits: 0,\r\n      cacheMisses: 0,\r\n      dbQueries: 0,\r\n      dbDuration: 0,\r\n      apiCalls: 0,\r\n      apiDuration: 0,\r\n      errors: 0\r\n    });\r\n    \r\n    return result;\r\n  } catch (error) {\r\n    const duration = Date.now() - startTime;\r\n    \r\n    // Record error\r\n    performanceManager.recordRequest(`async:${operationName}`, {\r\n      requestId: crypto.randomUUID(),\r\n      startTime,\r\n      endTime: startTime + duration,\r\n      duration,\r\n      statusCode: 500,\r\n      responseSize: 0,\r\n      cacheHits: 0,\r\n      cacheMisses: 0,\r\n      dbQueries: 0,\r\n      dbDuration: 0,\r\n      apiCalls: 0,\r\n      apiDuration: 0,\r\n      errors: 1\r\n    });\r\n    \r\n    throw error;\r\n  }\r\n}"],"names":[],"mappings":";;;AASO,SAAS,yBAAA,CACd,OACA,SAAA,EACU;AACV,EAAA,OAAO,OAAO,OAAA,KAAY;AACxB,IAAA,MAAM,kBAAA,GAAqB,0BAA0B,WAAA,EAAY;AACjE,IAAA,MAAM,SAAA,GAAY,KAAK,GAAA,EAAI;AAC3B,IAAA,MAAM,MAAA,GAAS,QAAQ,OAAA,CAAQ,MAAA;AAC/B,IAAA,MAAM,GAAA,GAAM,IAAI,GAAA,CAAI,OAAA,CAAQ,QAAQ,GAAG,CAAA;AACvC,IAAA,MAAM,WAAW,GAAA,CAAI,QAAA;AAGrB,IAAA,MAAM,UAAA,GAAa,SAAA,IAAa,CAAA,EAAG,MAAM,IAAI,QAAQ,CAAA,CAAA;AAErD,IAAA,IAAI;AAEF,MAAA,MAAM,QAAA,GAAW,MAAM,KAAA,CAAM,OAAO,CAAA;AAGpC,MAAA,MAAM,QAAA,GAAW,IAAA,CAAK,GAAA,EAAI,GAAI,SAAA;AAC9B,MAAA,kBAAA,CAAmB,cAAc,UAAA,EAAY;AAAA,QAC3C,SAAA,EAAW,OAAO,UAAA,EAAW;AAAA,QAC7B,SAAA;AAAA,QACA,SAAS,SAAA,GAAY,QAAA;AAAA,QACrB,QAAA;AAAA,QACA,YAAY,QAAA,CAAS,MAAA;AAAA,QACrB,YAAA,EAAc,SAAS,QAAA,CAAS,OAAA,CAAQ,IAAI,gBAAgB,CAAA,IAAK,KAAK,EAAE,CAAA;AAAA,QACxE,WAAW,QAAA,CAAS,OAAA,CAAQ,GAAA,CAAI,aAAa,IAAI,CAAA,GAAI,CAAA;AAAA,QACrD,aAAa,QAAA,CAAS,OAAA,CAAQ,GAAA,CAAI,aAAa,IAAI,CAAA,GAAI,CAAA;AAAA,QACvD,SAAA,EAAW,CAAA;AAAA,QACX,UAAA,EAAY,CAAA;AAAA,QACZ,QAAA,EAAU,CAAA;AAAA,QACV,WAAA,EAAa,CAAA;AAAA,QACb,MAAA,EAAQ;AAAA,OACT,CAAA;AAED,MAAA,OAAO,QAAA;AAAA,IACT,SAAS,KAAA,EAAO;AAEd,MAAA,MAAM,QAAA,GAAW,IAAA,CAAK,GAAA,EAAI,GAAI,SAAA;AAC9B,MAAA,kBAAA,CAAmB,cAAc,UAAA,EAAY;AAAA,QAC3C,SAAA,EAAW,OAAO,UAAA,EAAW;AAAA,QAC7B,SAAA;AAAA,QACA,SAAS,SAAA,GAAY,QAAA;AAAA,QACrB,QAAA;AAAA,QACA,UAAA,EAAY,GAAA;AAAA,QACZ,YAAA,EAAc,CAAA;AAAA,QACd,SAAA,EAAW,CAAA;AAAA,QACX,WAAA,EAAa,CAAA;AAAA,QACb,SAAA,EAAW,CAAA;AAAA,QACX,UAAA,EAAY,CAAA;AAAA,QACZ,QAAA,EAAU,CAAA;AAAA,QACV,WAAA,EAAa,CAAA;AAAA,QACb,MAAA,EAAQ;AAAA,OACT,CAAA;AAGD,MAAA,MAAM,KAAA;AAAA,IACR;AAAA,EACF,CAAA;AACF;;;;"}